"use strict"

// Import required classes and utility functions
import CollisionDetector from "./collision-detector.js"
import Observable from "./observable.js"

// in GameWorld there is only GameWorld, a perpetual NOW (divided into ~60 frames per seconds)
export class GameWorld extends Observable {
    #gameState
    #timeRemaining

    // set #deltaTime to 1 to avoid a NaN error when starting the game loop
    static #deltaTime = 1

    constructor() {
        super()
    }


    // Getter for private static #deltaTime variable 
    // (No setter defined, as #deltaTime should only be set by the GameWorld class in the game loop)
    static get deltaTime() {
        return GameWorld.#deltaTime
    }

    clearCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
    }



    // the main game loop
    loop(timeStamp, scene = this.currentScene) {
        // console.log("this.isSceneOver: ", this.isSceneOver)
        // Guard clauses to exit the loop if any of the conditions are met


        // Timekeeping, setting deltaTime with each frame
        GameWorld.#deltaTime = (timeStamp - this.lastTime) / 1000
        this.lastTime = timeStamp

        // Clear the canvas
        this.clearCanvas()

        // Update the currentScene(includes background layers, player sprite and spawned items)
        scene.update(GameWorld.#deltaTime, this.input)

        // Detect collisions by calling CollisionDetector (using AABB algorithm)
        if (this.player.stats.isAlive === true) {
            this.detectCollisions()
            this.detectProjectileCollisions()
            this.detectPlayerByEnemies()
        }

        // console.log("player.dy = ", this.player.dy)

        // Draw the scene to the canvas
        scene.draw(this.ctx, true, true, true)

        // requestAnimationFrame to get next frame
        requestAnimationFrame(this.loop.bind(this))


    }

    detectCollisions() {
        let colliders = this.spawner.getAllSpawnedObjects()
        // console.log(colliders)

        // console.log("colliders: ", colliders.length)
        if (colliders.length !== 0 || colliders !== undefined) {
            colliders.forEach((collider) => {
                const playerInRange = collider.detectPlayer({ 'dx': this.player.dx, 'dy': this.player.dy })
                if (playerInRange) {

                    let collisionObject = CollisionDetector.detectBoxCollision(this.player, collider)
                    if (collisionObject) {
                        // console.log(collisionObject)
                        this.notify(collisionObject)
                    }
                }
            })

        }
    }

    detectPlayerByEnemies() {
        let enemies = this.spawner.getAllEnemies()
        if (enemies.length === 0 || !enemies) {
            // console.log("No enemies detected")
        }
        enemies.forEach((enemy) => {
            if (enemy.detectPlayer({ 'dx': this.player.dx, 'dy': this.player.dy }, 200)) {
                enemy.launchProjectile({ velocityX: 10, velocityY: getRandomInt(100, 300) })
            }
        })
    }

    detectProjectileCollisions() {
        let enemies = this.spawner.getAllEnemies()
        // console.log(enemies)
        if (enemies.length !== 0 || enemies !== undefined) {
            enemies.forEach((enemy) => {
                if (enemy instanceof Enemy) {
                    // enemy.launchProjectile({ velocityX: 0, velocityY: getRandomInt(50, 300) })
                    // console.dir(enemy.projectile)
                    let collisionProjectileObject = CollisionDetector.detectBoxCollision(this.player, enemy.projectile)
                    // if (collisionProjectileObject) console.dir(collisionProjectileObject)
                    if (collisionProjectileObject) {
                        this.notify(collisionProjectileObject)
                    }
                }
            })
        }
    }




    receiveUpdate(data) {
        // console.log("gameworld received :", data)
    }



}

